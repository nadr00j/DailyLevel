import { useEffect, useRef, useCallback, useState, useMemo } from 'react';
import { useGamificationStoreV21 } from '@/stores/useGamificationStoreV21';
import { usePixelBuddyStore } from '@/stores/usePixelBuddyStore';
import { useHabitStore } from '@/stores/useHabitStore';
import { useAuthStore } from '@/stores/useAuthStore';
import { useTasks } from '@/hooks/useTasks';
import { useGoals } from '@/hooks/useGoals';

// Flag para controlar logs de debug em produ√ß√£o
const IS_DEBUG = process.env.NODE_ENV === 'development';

export const VitalityListener = () => {
  // ‚úÖ TODOS OS HOOKS NO IN√çCIO (antes de qualquer early return)
  const { user, isAuthenticated } = useAuthStore();
  const [isInitialLoading, setIsInitialLoading] = useState(true);
  const { xp, vitality, mood, addXp } = useGamificationStoreV21();
  const { setBase, initializeFromGamification } = usePixelBuddyStore();
  const { habits } = useHabitStore();
  const habitLogs = useHabitStore(state => state.logs);
  const { todayTasks } = useTasks();
  const { activeGoals } = useGoals();
  
  // ‚úÖ TODOS OS useRef TAMB√âM NO IN√çCIO
  const prevXpRef = useRef(xp);
  const prevHabitsRef = useRef<Record<string, any>>({});
  const prevTasksRef = useRef<any[]>([]);
  const prevGoalsRef = useRef<any[]>([]);
  const processedEventsRef = useRef<Set<string>>(new Set());
  const isProcessingRef = useRef<boolean>(false);
  const lastProcessedTimeRef = useRef<number>(0);
  
  // ‚úÖ Fun√ß√£o auxiliar para processar eventos de forma segura (useCallback) - OTIMIZADA
  const processEventSafely = useCallback(async (eventKey: string, eventType: string, eventData: any) => {
    if (IS_DEBUG) {
      console.log('‚ö° [VitalityListener] Processando evento:', { eventType, eventData: { type: eventData.type, tags: eventData.tags } });
    }
    
    // Evitar processamento simult√¢neo
    if (isProcessingRef.current) {
      if (IS_DEBUG) console.log('[VitalityListener] J√° processando evento, ignorando:', eventKey);
      return;
    }

    // Evitar processamento muito frequente (m√≠nimo 100ms entre eventos) - OTIMIZADO
    const now = Date.now();
    if (now - lastProcessedTimeRef.current < 100) {
      if (IS_DEBUG) console.log('[VitalityListener] Processamento muito frequente, ignorando:', eventKey);
      return;
    }

    // Verificar se o evento j√° foi processado
    if (processedEventsRef.current.has(eventKey)) {
      if (IS_DEBUG) console.log('[VitalityListener] Evento j√° processado, ignorando:', eventKey);
      return;
    }

    try {
      isProcessingRef.current = true;
      lastProcessedTimeRef.current = now;
      processedEventsRef.current.add(eventKey);

      if (IS_DEBUG) {
        console.log('[VitalityListener] Processando evento:', { eventKey, eventType, eventData });
      }

      // OTIMIZA√á√ÉO: Remover verifica√ß√£o Supabase desnecess√°ria
      // O addXp j√° tem l√≥gica de preven√ß√£o de duplica√ß√£o
      const userId = useAuthStore.getState().user?.id;
      if (!userId) {
        if (IS_DEBUG) console.warn('‚ö†Ô∏è [VitalityListener] Usu√°rio n√£o autenticado, ignorando evento');
        return;
      }

      // Verificar se h√° tags v√°lidas antes de chamar addXp
      if (eventData.tags && eventData.tags.length > 0) {
        if (IS_DEBUG) {
          console.log('üéØ [VitalityListener] Chamando addXp com:', {
            type: eventData.type || 'task',
            tags: eventData.tags,
            explicitCategory: eventData.category
          });
        }
        
        // Passar categoria expl√≠cita para addXp
        addXp(eventData.type || 'task', eventData.tags, eventData.category);
      } else {
        if (IS_DEBUG) {
          console.warn('‚ö†Ô∏è [VitalityListener] Evento sem tags v√°lidas ignorado:', { eventType, eventData });
        }
      }
    } catch (error) {
      console.error('[VitalityListener] Erro ao processar evento:', eventKey, error);
      // Remover da lista de processados em caso de erro para permitir retry
      processedEventsRef.current.delete(eventKey);
    } finally {
      isProcessingRef.current = false;
    }
  }, [addXp]);
  
  // Limpar cache de eventos processados - OTIMIZADO
  useEffect(() => {
    const cleanupInterval = setInterval(() => {
      const currentSize = processedEventsRef.current.size;
      // OTIMIZA√á√ÉO: S√≥ limpar se h√° mais de 50 eventos no cache
      if (currentSize > 50) {
        if (IS_DEBUG) {
          console.log(`[VitalityListener] Limpando cache de eventos processados (${currentSize} itens)`);
        }
        processedEventsRef.current.clear();
      }
    }, 5 * 60 * 1000); // OTIMIZADO: Reduzido de 10min para 5min
    
    return () => clearInterval(cleanupInterval);
  }, []);

  // Aguardar carregamento inicial dos dados - OTIMIZADO
  useEffect(() => {
    const timer = setTimeout(() => {
      if (IS_DEBUG) {
        console.log('[VitalityListener] Carregamento inicial conclu√≠do, iniciando detec√ß√£o de eventos');
        console.log('[VitalityListener] Inicializando PixelBuddy com:', { xp, vitality });
      }
      setIsInitialLoading(false);
      
      // Sempre inicializar, mesmo com valores 0 (usu√°rio novo)
      initializeFromGamification(xp, vitality);
    }, 2000); // OTIMIZADO: Reduzido de 5s para 2s

    return () => clearTimeout(timer);
  }, []); // Executa apenas uma vez na montagem

  // OTIMIZA√á√ÉO: Memoizar c√°lculo do PixelBuddy para evitar rec√°lculos desnecess√°rios
  const pixelBuddyAssets = useMemo(() => {
    // Atualizar body baseado na vitalidade
    let newBody: string;
    if (vitality < 25) {
      newBody = '/Nadr00J/bodies/body_lvl1.png';
    } else if (vitality < 50) {
      newBody = '/Nadr00J/bodies/body_lvl2.png';
    } else {
      newBody = '/Nadr00J/bodies/body_lvl3.png';
    }
    
    // Atualizar head baseado na vitalidade
    let newHead: string;
    if (vitality < 25) {
      newHead = '/Nadr00J/heads/head_tired.png';
    } else if (vitality < 50) {
      newHead = '/Nadr00J/heads/head_sad.png';
    } else if (vitality < 75) {
      newHead = '/Nadr00J/heads/head_neutral.png';
    } else if (vitality < 90) {
      newHead = '/Nadr00J/heads/head_happy.png';
    } else {
      newHead = '/Nadr00J/heads/head_confident.png';
    }
    
    return { newBody, newHead };
  }, [vitality]); // Apenas recalcula quando vitality muda

  // Atualizar PixelBuddy quando assets mudam
  useEffect(() => {
    if (IS_DEBUG) {
      console.log('[VitalityListener] Atualizando PixelBuddy:', { 
        xp, 
        vitality, 
        ...pixelBuddyAssets 
      });
    }
    
    setBase('body', pixelBuddyAssets.newBody);
    setBase('head', pixelBuddyAssets.newHead);
  }, [pixelBuddyAssets, setBase]);

  // OTIMIZA√á√ÉO: Memoizar dados de hoje para evitar rec√°lculos
  const todayString = useMemo(() => new Date().toISOString().split('T')[0], []);

  // Detectar conclus√£o de h√°bitos - OTIMIZADO
  useEffect(() => {
    // N√£o processar durante carregamento inicial
    if (isInitialLoading) {
      if (IS_DEBUG) console.log('[VitalityListener] Ignorando detec√ß√£o de h√°bitos durante carregamento inicial');
      return;
    }
    
    const prevHabits = prevHabitsRef.current;
    
    // OTIMIZA√á√ÉO: Processar apenas h√°bitos que mudaram
    let hasChanges = false;
    
    // Verificar se algum h√°bito foi conclu√≠do hoje
    Object.entries(habits).forEach(([habitId, habit]) => {
      const todayLog = habitLogs[habitId]?.[todayString] || 0;
      const prevTodayLog = prevHabits[habitId]?.todayLog || 0;
      
      // OTIMIZA√á√ÉO: S√≥ processar se houve mudan√ßa real
      if (todayLog !== prevTodayLog) {
        hasChanges = true;
        const isCompletedToday = todayLog >= habit.targetCount;
        const wasCompletedBefore = prevTodayLog >= habit.targetCount;
        
        // Se o h√°bito foi rec√©m conclu√≠do (n√£o estava completo antes e agora est√°)
        if (isCompletedToday && !wasCompletedBefore) {
          // Usar ID do h√°bito + data + timestamp para garantir unicidade
          const eventKey = `habit-${habitId}-completed-${todayString}-${Date.now()}`;
          
          if (IS_DEBUG) {
            console.log('[VitalityListener] H√°bito conclu√≠do detectado:', { 
              habitId, 
              habitName: habit.name, 
              todayLog, 
              targetCount: habit.targetCount,
              eventKey 
            });
          }
          
          processEventSafely(eventKey, 'HABIT_DONE', {
            habitId,
            habitName: habit.name,
            type: 'habit',
            tags: [habit.name],
            category: habit.categories?.[0]
          });
        }
      }
    });
    
    // OTIMIZA√á√ÉO: S√≥ atualizar refer√™ncia se houve mudan√ßas
    if (hasChanges) {
      const habitsWithLogs = Object.fromEntries(
        Object.entries(habits).map(([id, habit]) => [
          id, 
          { ...habit, todayLog: habitLogs[id]?.[todayString] || 0 }
        ])
      );
      prevHabitsRef.current = habitsWithLogs;
    }
  }, [habits, habitLogs, processEventSafely, isInitialLoading, todayString]);

  // Detectar conclus√£o de tarefas - OTIMIZADO
  useEffect(() => {
    // N√£o processar durante carregamento inicial
    if (isInitialLoading) {
      if (IS_DEBUG) console.log('[VitalityListener] Ignorando detec√ß√£o de tarefas durante carregamento inicial');
      return;
    }
    
    const currentTasks = todayTasks || [];
    const prevTasks = prevTasksRef.current;
    
    // OTIMIZA√á√ÉO: Log reduzido - apenas quando h√° mudan√ßas significativas
    if (IS_DEBUG && currentTasks.length !== prevTasks.length) {
      console.log('[VitalityListener] N√∫mero de tarefas mudou:', { 
        currentTasksLength: currentTasks.length, 
        prevTasksLength: prevTasks.length
      });
    }
    
    // OTIMIZA√á√ÉO: Usar Map para busca mais r√°pida de tarefas anteriores
    const prevTasksMap = new Map(prevTasks.map(t => [t.id, t]));
    
    // Verificar se alguma tarefa foi conclu√≠da
    currentTasks.forEach(task => {
      const prevTask = prevTasksMap.get(task.id);
      
      // OTIMIZA√á√ÉO: S√≥ processar se houve mudan√ßa real no estado
      const isTaskCompleted = task.completed && !prevTask?.completed;
      
      if (isTaskCompleted) {
        // Usar ID da tarefa + timestamp atual para garantir unicidade
        const eventKey = `task-${task.id}-completed-${Date.now()}`;
        
        if (IS_DEBUG) {
          console.log('üéØ [VitalityListener] Tarefa conclu√≠da detectada:', { 
            taskId: task.id, 
            taskTitle: task.title,
            eventKey,
            completed: task.completed
          });
        }
        
        processEventSafely(eventKey, 'TASK_DONE', {
          taskId: task.id,
          taskTitle: task.title,
          type: 'task',
          tags: [task.title],
          category: task.category
        });
      }
    });
    
    prevTasksRef.current = currentTasks;
  }, [todayTasks, processEventSafely, isInitialLoading]);

  // Detectar conclus√£o de metas - OTIMIZADO
  useEffect(() => {
    // N√£o processar durante carregamento inicial
    if (isInitialLoading) {
      if (IS_DEBUG) console.log('[VitalityListener] Ignorando detec√ß√£o de metas durante carregamento inicial');
      return;
    }
    
    const currentGoals = activeGoals || [];
    const prevGoals = prevGoalsRef.current;
    
    // OTIMIZA√á√ÉO: Usar Map para busca mais r√°pida de metas anteriores
    const prevGoalsMap = new Map(prevGoals.map(g => [g.id, g]));
    
    // Verificar se alguma meta foi conclu√≠da
    currentGoals.forEach(goal => {
      const prevGoal = prevGoalsMap.get(goal.id);
      
      // APENAS detectar conclus√£o real (meta existia antes E mudou para conclu√≠da)
      if (prevGoal && goal.isCompleted && !prevGoal.isCompleted) {
        // Usar ID da meta + timestamp atual para garantir unicidade
        const eventKey = `goal-${goal.id}-completed-${Date.now()}`;
        
        if (IS_DEBUG) {
          console.log('[VitalityListener] Meta conclu√≠da detectada:', { 
            goalId: goal.id, 
            goalTitle: goal.title, 
            eventKey 
          });
        }
        
        processEventSafely(eventKey, 'GOAL_DONE', {
          goalId: goal.id,
          goalTitle: goal.title,
          type: 'goal',
          tags: [goal.title], // Nome da meta nas tags
          category: goal.category // Incluir categoria para salvar corretamente
        });
      }
    });
    
    prevGoalsRef.current = currentGoals;
  }, [activeGoals, processEventSafely, isInitialLoading]);

  // OTIMIZA√á√ÉO: Removido useEffect de detec√ß√£o de XP
  // O XP √© atualizado diretamente pelo addXp, n√£o precisamos detectar mudan√ßas
  // Isso evita loops infinitos e processamento desnecess√°rio

  // ‚úÖ Early return DEPOIS de todos os hooks
  if (!isAuthenticated || !user?.id) {
    return null;
  }

  // Este componente n√£o renderiza nada, apenas escuta eventos
  return null;
};
